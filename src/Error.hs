module Error where

import Common

-- Don't use ErrM generated by bnfc, because I don't like to modify machine-generated
-- code. So create a new one based on ErrM but with ErrorDetail providing various info.
data Error a
  = Ok a
  | Fail ErrorDetail
  deriving (Show)

instance Functor Error  where
  fmap _ (Fail rs) = Fail rs
  fmap f (Ok a) = Ok (f a)

instance Applicative Error where
  pure = Ok

  Ok f <*> m = fmap f m
  Fail rs <*> _m = Fail rs

instance Monad Error where
  (Ok x) >>= k = k x
  Fail rs >>= _ = Fail rs

data ErrorDetail
  = EDAssertFail PPos
  | EDBind String PPos
  | EDCantBePrimitiveType String PPos
  | EDCantCompare PPos String String
  | EDCantUseWiderBind String PPos
  | EDDivideByZero PPos
  | EDFuncAlreadyDeclared PPos
  | EDFuncArgRepeated String PPos
  | EDFuncNotFound String PPos
  | EDInvalidNumParams PPos Int Int
  | EDNoMember PPos String String
  | EDNoReturnNonVoid PPos
  | EDNoReturn PPos
  | EDParsingError String
  | EDReturnVoid PPos
  | EDScanError String PPos
  | EDStructArgRepeated String PPos
  | EDTupleNotAllowed PPos
  | EDTupleNumbersDontMatch PPos Int Int
  | EDTupleReturned PPos
  | EDTypeAlreadyDeclared PPos
  | EDTypeError String String PPos
  | EDTypeNotFound String PPos
  | EDUncoughtedExc String PPos -- This should not happen
  | EDUnexpectedBreak PPos
  | EDUnexpectedContinue PPos
  | EDUnexpectedReturn PPos
  | EDValueReturned PPos
  | EDVarAlreadyDeclared PPos
  | EDVarIsVoid PPos
  | EDVarNotStruct PPos
  | EDVarReadOnly PPos
  | EDVarNotFound String PPos
  | EDVarNotInitialized PPos

-- Extract position from the error. Almost every error details provides it.
errorPos :: ErrorDetail -> PPos
errorPos (EDAssertFail p) = p
errorPos (EDBind _ p) = p
errorPos (EDCantBePrimitiveType _ p) = p
errorPos (EDCantCompare p _ _) = p
errorPos (EDCantUseWiderBind _ p) = p
errorPos (EDDivideByZero p) = p
errorPos (EDFuncAlreadyDeclared p) = p
errorPos (EDFuncArgRepeated _ p) = p
errorPos (EDFuncNotFound _ p) = p
errorPos (EDInvalidNumParams p _ _) = p
errorPos (EDNoMember p _ _) = p
errorPos (EDNoReturnNonVoid p) = p
errorPos (EDNoReturn p) = p
errorPos (EDParsingError _) = Nothing
errorPos (EDReturnVoid p) = p
errorPos (EDScanError _ p) = p
errorPos (EDStructArgRepeated _ p) = p
errorPos (EDTupleNotAllowed p) = p
errorPos (EDTupleNumbersDontMatch p _ _) = p
errorPos (EDTupleReturned p) = p
errorPos (EDTypeAlreadyDeclared p) = p
errorPos (EDTypeError _ _ p) = p
errorPos (EDTypeNotFound _ p) = p
errorPos (EDUncoughtedExc _ p) = p
errorPos (EDUnexpectedBreak p) = p
errorPos (EDUnexpectedContinue p) = p
errorPos (EDUnexpectedReturn p) = p
errorPos (EDValueReturned p) = p
errorPos (EDVarAlreadyDeclared p) = p
errorPos (EDVarIsVoid p) = p
errorPos (EDVarNotStruct p) = p
errorPos (EDVarReadOnly p) = p
errorPos (EDVarNotFound _ p) = p
errorPos (EDVarNotInitialized p) = p

instance Show ErrorDetail where
  show (EDAssertFail _) = "Assertion failed."
  show (EDBind n _) = "Variable `" ++ n ++ "' is used, but not binded."
  show (EDCantBePrimitiveType t _) = "Type must be a struct, not a primitive type." ++
    " (Was: `" ++ t ++ "').";
  show (EDCantCompare _ l r) = "Can't compare types `" ++ l ++ "' and `" ++ r ++
    "'. Only builtin types with matching type can be compared."
  show (EDCantUseWiderBind n _) = "Can't call function `" ++ n ++ "' because it " ++
    "refers to the wider scope than the current binded block does."
  show (EDDivideByZero _) = "Divide by zero."
  show (EDFuncAlreadyDeclared _) = "Function is already declared in the current scope."
  show (EDFuncArgRepeated name _) = "Function argument named `" ++ name ++
    "' is repeated more than once."
  show (EDFuncNotFound name _) = "Function `" ++ name ++ "' not in scope."
  show (EDInvalidNumParams _ expected got) = "Invalid number of parameters. " ++
    "Expected " ++ show expected ++ ", but got " ++ show got ++ "."
  show (EDNoMember _ tname memb) = "Struct `" ++ tname ++ "' has no member `" ++
    memb ++ "'."
  show (EDNoReturn _) = "Function that returns a value didn't return."
  show (EDNoReturnNonVoid _) = "Void function cannot return a value."
  show (EDParsingError str) = "Parsing error: " ++ str ++ "."
  show (EDReturnVoid _) = "Return without a value when value was expected."
  show (EDScanError n _) = "Can't scan `" ++ n ++ "'. Not a builtin type."
  show (EDStructArgRepeated name _) = "Struct member named `" ++ name ++
    "' is repeated more than once."
  show (EDTupleNotAllowed _) = "Tuple is not allowed here."
  show (EDTupleNumbersDontMatch _ l r) = "Numbers of elements in asigned tuples " ++
    "don't much: left has " ++ show l ++ ", but right has " ++ show r ++ "."
  show (EDTupleReturned _) = "Tuple returned, when single variable expected."
  show (EDTypeAlreadyDeclared _) = "Struct is already declared in the current scope."
  show (EDTypeError expected got _) = "Type error: " ++ "expected `" ++ expected ++
    "', got `" ++ got ++ "'."
  show (EDTypeNotFound tname _) = "Type `" ++ tname ++ "' not in scope."
  show (EDUncoughtedExc excType _) = "Uncoughted: `" ++ show excType ++ "'."
  show (EDUnexpectedBreak _) = "`break' is not allowed here."
  show (EDUnexpectedContinue _) = "`continue' is not allowed here."
  show (EDUnexpectedReturn _) = "`return' is not allowed here."
  show (EDValueReturned _) = "Single variable returned, when tuple was expected."
  show (EDVarAlreadyDeclared _) = "Variable is already declared in the current scope."
  show (EDVarNotStruct _) = "Variable or member is not a struct."
  show (EDVarIsVoid _) = "Void variable is not allowed here."
  show (EDVarReadOnly _) = "Variable is read only."
  show (EDVarNotFound name _) = "Variable `" ++ name ++ "' not in scope."
  show (EDVarNotInitialized _) = "Variable was not initialized."

getErrorMsg :: ErrorDetail -> String -> String
getErrorMsg err fname = (showFCol (errorPos err) fname) ++ show err
  where
    showFCol :: PPos -> String -> String
    showFCol (Just (l, c)) fnm = fnm ++ ":" ++ show l ++ ":" ++ show c ++ ": "
    showFCol Nothing fnm = fnm ++ ": "

-- Convert Maybe a to Error a. If value is Nothing return an error with
-- provided description.
errorFromMaybe :: ErrorDetail -> Maybe a -> Error a
errorFromMaybe _ (Just x) = return x
errorFromMaybe det Nothing = Fail det

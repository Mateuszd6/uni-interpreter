-- TODO: This is smarter way to write empty?
-- [].       [Stm]    ::= ; -- TODO: move this to statemetns, place more logically.
-- (:).      [Stm]    ::= Stm [Stm] ;

entrypoints Program ;
Prog.       Program ::= [Stm] ;

-- This makes parsing much easier and enforces that ugly things like (1 + 2).foo
-- won't parse. Our language is simple enough that it makes sense; no lists,
-- records just strings so the only thing we would like to have on the LHS when
-- e.g. assigning, is either an existing variable name, or its member.
LValueVar.  LValue ::= Ident ;
LValueMemb. LValue ::= LValue "." Ident ;

EPlus.   Exp   ::= Exp "+" Exp2 ;
EMinus.  Exp   ::= Exp "-" Exp2 ;

ETimes.  Exp2  ::= Exp2 "*" Exp3 ;
EDiv.    Exp2  ::= Exp2 "/" Exp3 ;

EPow.    Exp3  ::= Exp3 "^" Exp4 ;

EEq.     Exp4  ::= Exp4 "==" Exp5 ;
ENeq.    Exp4  ::= Exp4 "!=" Exp5 ;
EGeq.    Exp4  ::= Exp4 ">=" Exp5 ;
ELeq.    Exp4  ::= Exp4 "<=" Exp5 ;
EGt.     Exp4  ::= Exp4 ">"  Exp5 ;
ELt.     Exp4  ::= Exp4 "<"  Exp5 ;

ELor.    Exp5  ::= Exp5 "||" Exp6 ;
ELand.   Exp5  ::= Exp5 "&&" Exp6 ;
EXor.    Exp5  ::= Exp5 "^^" Exp6 ;

EFnCall. Exp6  ::= Ident InvokeExprList ;
EIife.   Exp6  ::= FunDecl InvokeExprList ; -- IIFE (more in docs).

ELValue. Exp7  ::= LValue ;

EString. Exp8  ::= String ;
EInt.    Exp8  ::= Integer ;
EBool.   Exp8  ::= Boolean ;

-- Equivalent to: _. Exp ::= Exp1 ; (...) _. Exp8 ::= "(" Exp ")" ;
coercions Exp 8 ;

(:[]).   [Exp] ::= Exp ;
(:).     [Exp] ::= Exp "," [Exp] ;

-- Tuple is not a stand-alone expression (more in docs).
EOTRegular. ExpOrTuple ::= Exp;
EOTTuple.   ExpOrTuple ::= "[" [Exp] "]";

-- Split into Stm1 and Stm to avoid confilits around if - else, which happen
-- becase we are not using endif or anything like this.
-- TODO: We cannot do for () if () {}
SIf.     Stm  ::= IfStm ElseStm ; -- ElseStm can be empty to allow single if.
SExp.    Stm1 ::= Exp ";" ;
SDecl.   Stm1 ::= Decl ";" ;
SFDecl.  Stm1 ::= Ident "::" FunDecl ;
SSDecl.  Stm1 ::= Ident "::" StructDecl ;
SAssign. Stm1 ::= LValue "=" Exp ";" ;
SIgnore. Stm1 ::= "_" "=" ExpOrTuple ";" ; -- Not usefull, but would be weird if it didn't parse
STDecl.  Stm1 ::= TupleTarget ":" "=" ExpOrTuple ";" ; -- Declare new variables (types are always deduced)
STAssign.Stm1 ::= TupleTarget "=" ExpOrTuple ";" ; -- Tie existing variables. -- TODO: support '_'
SReturn. Stm1 ::= "return" ReturnExp ";" ;
SForInt. Stm1 ::= "for" "(" Ident ":" Exp ".." Exp ")" Stm1 ; -- This declares new variable.
SWhile.  Stm1 ::= "while" "(" Exp ")" Stm1 ;
SBreak.  Stm1 ::= "break" ";" ;
SCont.   Stm1 ::= "continue" ";" ;
SBlock.  Stm1 ::= FunBind "{" [Stm] "}" ;
_.       Stm  ::= Stm1 ;

(:[]).   [Stm] ::= Stm ;
(:).     [Stm] ::= Stm [Stm] ;

TAssgn.    TupleTarget ::= "[" [IdentOrIgnr] "]" ;

IOIName.   IdentOrIgnr ::= Ident ;
IOIIgnore. IdentOrIgnr ::= "_" ;
(:[]).   [IdentOrIgnr] ::= IdentOrIgnr ;
(:).     [IdentOrIgnr] ::= IdentOrIgnr "," [IdentOrIgnr] ;

RExNone.    ReturnExp ::= ; -- Allowed for void functions.
RExRegular. ReturnExp ::= ExpOrTuple ;

-- TODO: Split fun definition with declaration, for clarity
FDDefault. FunDecl ::= FunParams FunBind FuncRetT "{" [Stm] "}" ;
SDDefault. StructDecl ::= "struct" "{" StructMembers "}" ;

SMDefault. StructMembers ::= [DeclStructMember] ;
SMEmpty.   StructMembers ::= ; -- To allow empty structs.

FDBindDefault.FunBind ::= "!" "(" [Ident] ")";
FDBindPure.   FunBind ::= "!" "(" ")" ; -- bind () is same as not specifying bind at all
FDBindPure2.  FunBind ::= "!" ; -- user is allowed to skip paren here
FDBindNone.   FunBind ::= ; -- No bind means the function can refer to any variable from outside scope.

DDeclUninit.  Decl ::= Ident ":" Type ; -- Declare do not assign value.
DDeclAssign.  Decl ::= Ident ":" Type "=" Exp ; -- Decalre + assign, type is explicit.
DDeclDeduce.  Decl ::= Ident ":" "=" Exp ; -- Decalre + assign, type is deduced.

-- TODO: Tie could actually have LValues, not only idents like:
-- '[foo.x, foo.y] = funcitonThatReturnsAPair();' but I don't like the idea
-- fundamentally. Also it could generate some ugly conflicts.

IIf.        IfStm   ::= "if" "(" Exp ")" Stm1 ;
IElse.      ElseStm ::= "else" Stm ;
IElseEmpty. ElseStm ::= ;

IELDefault. InvokeExprList ::= "(" [Exp] ")" ;
IELEmpty.   InvokeExprList ::= "(" ")" ;

DDeclBasic. DeclBasic   ::= Ident ":" Type ;
(:[]).      [DeclBasic] ::= DeclBasic ;
(:).        [DeclBasic] ::= DeclBasic "," [DeclBasic] ;

FPDefault.  FunParams   ::= "(" [DeclBasic] ")" ;
FPEmpty.    FunParams   ::= "(" ")" ;

-- Function return type, user is allowed to skip it, if func does not return
-- anything ('void' return type).
-- TODO: Rename to FuncRetType?
FRTDefault.  FuncRetT ::= "->" Type ;
FRTTuple.    FuncRetT ::= "->" "[" [Type] "]" ; -- Tuple (No nesting tuples).
FRTEmpty.    FuncRetT ::= ; -- User is allowed to skip -> when no return type.

DStrMem. DeclStructMember   ::= DeclBasic ;
(:[]).   [DeclStructMember] ::= DeclStructMember ";" ;
(:).     [DeclStructMember] ::= DeclStructMember ";" [DeclStructMember] ;

-- TODO: Empty functions do not parse.

TInt.     Type ::= "int" ;
TBool.    Type ::= "bool" ;
TString.  Type ::= "string" ;
TUserDef. Type ::= Ident ;

(:[]).   [Type]  ::= Type ;
(:).     [Type]  ::= Type "," [Type] ;

(:[]).   [Ident] ::= Ident ;
(:).     [Ident] ::= Ident "," [Ident] ;

BTrue.   Boolean ::= "true" ;
BFalse.  Boolean ::= "false" ;

comment "//" ; -- Regular C style comments both block and single-line.
comment "/*" "*/" ; -- Block comments can't be nested (like in C).
comment "#" ; -- To allow scripting

% Created 2020-04-29 Wed 20:49
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[margin=0.5in]{geometry}
\usepackage{minted}
\usepackage{xcolor}
\author{Mateusz Dudziński}
\date{\today}
\title{JPP - language specification}
\hypersetup{
 pdfauthor={Mateusz Dudziński},
 pdftitle={JPP - language specification},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.1.9)}, 
 pdflang={English}}
\begin{document}

\maketitle

\subsubsection*{Changes from the previous version}
\label{sec:orgd45f91c}
\begin{itemize}
\item Add 'readonly' variables and func params, as I've realized they are
obligatory in the 15-points milestone,
\item Don't use builtin functions - they were causing too much trouble,
\item Use pseudo-statement print and scan function (which accept any number of
args),
\item Added \texttt{assert} function that helps when testing,
\item Removed \texttt{die} function, because it is basically an equivalent of
\texttt{assert(false)},
\item Change some operator precedence because things like: \texttt\{if (1 + 3 >=
4)\} didn't parse. Now they do,
\item Add 'new' statement for initializing structs. Since the language does not
support nulls by design, when declaring variable of a struct type, there was
nothing that could go to the right-hand side instead of function call, which
seemed weird. The 'new' syntax is exactly the same as in C\# and is presented
at the end of \texttt{good/14-records.prg} test case,
\item Updated documentation according to these changes.
\end{itemize}


\section*{Basics:}
\label{sec:orgdf99fc8}
The following language is an imperative, statically typed, mostly-C-like
language, featuring with user-defined structs, local/unnamed functions with
advanced local variables visibility options, arguments passed by value (no
references), multiple return values (simple tuples) and type in variable
declarations.

The 'program' in a sequence of statements written from the top to the bottom.
Instructions are executed one-after-another.  Functions and variables declared
without parent scope are considered global.  User can never redefine a global
variable / function. Defined but not assigned variables don't have default
value and trying to use them (like uninitialized bool in if expression- or
integer for adding) causes interpreter to crash the program. Locally defined
symbols are visible in their scope (like in C). User can't redefine symbol in
the same scope. For example the following: \texttt\{ foo : int = 0; foo : int =
0; \} would parse but fails at runtime. Same rules apply to functions and
structs.

There is no \texttt{null} constant to which an expression can be
compared. This is by design, because nulls make type deduction much
harder. Each type declared but not given an initial value will have the value
equal to the default of its respective type. It means: \texttt{0}, \texttt{""}
and \texttt{false} for \texttt{int}, \texttt{string} and
\texttt{bool}. Structs have all their members initiated recursively.

\section*{Declarations:}
\label{sec:org7e2d01b}

\subsubsection*{Define variable.}
\label{sec:orgc02987e}
\begin{minted}{cpp}
// (type is either string / int / bool or user-defined struct (see: structs)):
variable_name : variable_type ;
foo : int ;
\end{minted}

\subsubsection*{Declare and assign value.}
\label{sec:org2d60f39}
\begin{minted}{cpp}
foo : int = 4;
\end{minted}

\subsubsection*{Declare, assign but deduce the type.}
\label{sec:org0daccd4}
\begin{minted}{cpp}
foo := 4;
\end{minted}

The idea is that user can 'skip' the part of declaration he does not want, like
skip the type if type can be deduced (deducing type works, because the language
is statically typed). Also the difference between declaration and simple
assigment is the \texttt{:} which appears in every type of declaration.

Asignments however:
\begin{minted}{cpp}
foo = 4;
\end{minted}
\ldots{} don't have this token and are simple C-like assignments.

\subsubsection*{Also read-only variables are supported:}
\label{sec:org495fbac}
\begin{minted}{cpp}
foo! := 4; // Foo is now read-only.
foo = 4; // Would cause an error.
\end{minted}


\subsection*{Expressions}
\label{sec:orgde17ba3}

Expressions are basic arithmetic and logic expressions taken straight from C,
expect operator \texttt{@} for string concatenation and IIFE (in grammar
called EIife, described later here in the 'functions' part).

\begin{minted}{cpp}
// Most of the syntax is C-like:
if (boolean_expr)
{
    statement();
    x := 1 + 2;
    y := "programming" @ " " @ "language";
}

if (true)
    statement();

if (ivokeFunctionThatReturnsBool())
    statement();

if (ivokeFunctionThatReturnsBool())
{
}

while (bar)
{
}

while (bar)
    if (foo)
	return 5;
\end{minted}

\subsubsection*{For loops}
\label{sec:org95e50bb}
For is a little different. There is no range-for loop, for loops only go
from integer to integer by one. The interpreter will decide (at runtime)
whether we are iterating upwards on downwards. Iterator variable is
read-only in the loop body, so can't be reassigned.

\begin{minted}{cpp}
for (new_var_name : 1 .. 2)
{
}

// Of course these don't have to be constants:
for (new_var_name : begin() .. end())
{
    // for and while loops support break and continue;
    break;
    continue;
}

// Also mixed with other expressions, braces (like in C) are not needed.
for (new_var_name : begin() .. end())
    if (foo)
    {
    }

for (new_var_name : begin() .. end())
    while (foo)
    {
    }

if (foo)
    for (new_var_name : begin() .. end())
    {
    }

while (foo)
    for (new_var_name : begin() .. end())
    {
    }

{ } // Empty blocks works

;;;; // trailing ';' are accepted and not present in  ast, thanks to bnfc.
\end{minted}

However things like \texttt{if ();}, \texttt{while ();} \texttt{for (...);}
\texttt{else ;} won't parse. It came out a bit accidentally, when I was
trying to eliminate parsing conflicts around \texttt{if else} expressions but I think
it can be considered a feature.

\subsubsection*{Struct definitions. Very similar to C, just with slightly different syntax.}
\label{sec:org887206d}
\begin{minted}{cpp}
foo :: struct
{
}

bar :: struct
{
    x : int;
}

baz :: struct
{
    x : int;
    y : int;
}

v3 :: struct
{
    x : int;
    y : int;
    z : int;
}

quater :: struct
{
    e : v3;
    w : int;
}

example_vector : v3;
example_quaterion : quater;
x_copy = example_vector.x; // Getting struct members like in C.
x_copy_q = example_quaterion.e.x; // dots can follow one another.
// nope := example_vector.(e.x); // stuff like this won't parse of course.

\end{minted}

Of course in the above examples, the variables would be uninitialized, which
would cause a runtime error.

\subsubsection*{Structs can be defined for the scope:}
\label{sec:org0695008}
\begin{minted}{cpp}
{
    foobar :: struct
    {
	zzz : string;
    }

    m : foobar;
    m.zzz = "mateusz";

    // 'new' syntax allowes us to assigne sturct fields on
    // declaration, avoiding anti-patter above. This is the same:
    n := new foobar { zzz = "mateusz" };

    // Of course type can be also given explicitely, but in this case
    // it is rather pointless.
    n' : foobar = new foobar { zzz = "mateusz" };
}
\end{minted}

\section*{Functions}
\label{sec:org37ec742}

Most important feature of the language is a \texttt{!} (bind) operator. This was design
to make code refactoring easier by specifying which variables can be accessed in
the block / lambda / function. There is a little difference between these
anyway.

\subsubsection*{Super boring example, regular named (global) function.}
\label{sec:org17c9235}
\begin{minted}{cpp}
// Function parameters also support read-only attribute. X can't be changed inside func body.
exmaple1 :: (x! : int, y : int) -> int
{
    return y * x;
}
\end{minted}

\subsubsection*{Return type can be ommited, if function does not return.}
\label{sec:orgff29359}
\begin{minted}{cpp}
out : int = 0;
exmaple2 :: (x : int, y : int)
{
    out = y * x;
}
\end{minted}

\subsubsection*{Function that binds a variable - only 'foo' and function params are visible inside the function body. Everything should be an interpreter error.}
\label{sec:org77a5e9e}
\begin{minted}{cpp}
foo : int = 12;
exmaple3 :: (x : int, y: int) !(foo) -> int
{
    return foo + y * x;
}
\end{minted}

\subsubsection*{This function is pure. It is not the same as skipping '!' - single '!' means unction can refer to \underline{non} variables (aka. is pure), skipping '!' allows it to refer to all variables (like in C).}
\label{sec:org0057017}
\begin{minted}{cpp}
foo : int = 12;
exmaple4 :: (x : int, y: int)! -> int
{
    // foo can't be accessed here, the function is pure.
    return y * x;
}
\end{minted}

\subsubsection*{This function is not pure, and can reference every variable in its scope. It means global variables + local scope variables, if function is defined in the local scope.}
\label{sec:org3b04078}
\begin{minted}{cpp}
foo : int = 12;
exmaple5 :: (x : int, y: int) -> int
{
    return foo + y * x;
}
\end{minted}

\subsubsection*{Nested functions.}
\label{sec:orgf9f9afc}
\begin{minted}{cpp}
exmaple6 :: (x : int, y: int)! -> int
{
    square :: (x : int)! -> int
    {
	return x * x;
    }

    return square(x) + square(y);
}
\end{minted}

\subsubsection*{Lambda expressions. Since we don't have a higher order funcs (no passing, no returning function), all we can do with it, is to immidietly invoke it (IIFE) This is usefull when we have block that caluclates something and we want to keep it as pure as possible.}
\label{sec:orgf5423f3}
\begin{minted}{cpp}
iife_example1 :: (x : int, y : int)!
{
    out : int = 0;

    {
	x = x + 6;
	y = y - x;
	x = x * y;
	y = x - 5;
	out = x + y;
    }
}
\end{minted}

\subsubsection*{We could make it a little more safe and refactoring friendly by binding x and y and out in the block, so that we can't refer to anything else.}
\label{sec:orgf3b156e}
\begin{minted}{cpp}
foo : int = 42;
iife_example2 :: (x : int, y : int)!
{
    out : int = 0;
    !(x, y, out)
    {
	x = x + 6;
	y = y - x;
	x = x * y;
	y = x - 5;
	out = x + y;
    }
}
\end{minted}

\subsubsection*{We have to declare out and then change if, which is ugly and bugprone, thats where IIFE comes to help us.}
\label{sec:org7ffd015}
\begin{minted}{cpp}
iife_example3 :: (x : int, y : int)!
{
    // We can define out and assgin it at the same time. Assing 'out' to
    // Immidietly Called Function Expression which can refer only to x and y
    // and computes something from them as purely as it is possible.
    out : int = () !(x, y) -> int {
	x = x + 6;
	y = y - x;
	x = x * y;
	y = x - 5;
	return x + y;
    }();

    // Alternatively, we could do:
    out : int = (x_ : int, y_ : int)! -> int {
	x_ = x_ + 6;
	y_ = y_ - x_;
	x_ = x_ * y_;
	y_ = x_ - 5;
	return x_ + y_;
    }();
    // ... which achieves the same, but is more ugly.
}
\end{minted}

The whole idea about it is that is is very easy to extract code from block
into 'binded' block or iife, into local function, into global function,
which all have a very similar syntax (lambda, aka. 'unnamed function'
definition syntax is the same as 'named function', but without the
name). Which is not what most languages offer (like in C++, lambdas have
everything differently than regular functions).

\section*{Tuples:}
\label{sec:org37b14a6}

Tuple syntax are (exclusively) square brackets. But the amount of stuff that
user can do to a tuple is very limited (by design). So there is no nested
tuples, No tuple 'type' and getting a variable by name (like
\texttt{foo.get<0>()} in C++) etc.  The only thing user can do with a tuple is
assign it or return it. However, assignment is possible with \texttt{:=} and
with \texttt{=}, which causes different things. \texttt{:=} declares new
variable, and \texttt{=} sets variables that already exists to their new
values.

Since tuple is not a stand-alone expression nesting tuples or just using them
as single statement does not parse. Using \_ inside a tuple match is just an
ignore. It can't however be used when \uline{returning} tuples - in that case all
values must be specified (Compare TupleExp and TupleTarget).

\begin{minted}{cpp}
{
    // Tuples can be used to create new variables:
    [x, y] := [1, 2]; // x and y and declared here.
}

{
    // Or to assign to already existing onces (like C++'s std::tie):
    x : int;
    y : int;
    [x, y] = [1, 2];
}

{
    // Also operator '_' is supported on the lhs of the tuple assignment.
    // Noe that if trying to replace 1 or 2 with _ it would not parse,
    // bacause rhs is list of expressions, and lhs identifiers / '_'.
    [_, y] := [1, 2];
}
\end{minted}

\subsubsection*{Tuples can be returned from the function:}
\label{sec:org1bfa430}
\begin{minted}{cpp}
tuple_example :: ()! -> [int, int] {
    x : int = 12;
    y : int = x * x;

    return [x, y];
}

// Or (of course) from the IIFE:
[x, y] := ()! -> [int, int] {
    x : int = 12;
    y : int = x * x;

    return [x, y];
}();
\end{minted}

Nesting tuples is not supported. Tuple is not stand-alone expression. Empty
tuples also are not supported. The following do not parse:
\begin{minted}{cpp}
// _ = []; // as opposed to '_ = [1];' which does.
// [1];
// if ([true]) {}
\end{minted}

Operator \_ also works for assignments, but \uline{not} for declarations, so:
\begin{minted}{cpp}
_ = "mateusz";
_ = [ 1, 2, "mateusz" ];
_ = foobar();
// ... would parse, but:
// _ := "mateusz";
// _ := [ 1, 2, "mateusz" ];
// _ := foobar();
// ... do not.
\end{minted}

\subsubsection*{The interpreter also provides \texttt{print}, \texttt{scan} and \texttt{assert} expressions}
\label{sec:org59eef2f}
\begin{itemize}
\item \texttt{print} - prints the expression to the screen. Must be a builtin
type. Printing structs is not supported, printing tuples would not even
parse, because tuples are not expressions.
\item \texttt{scan} - scan is a pseudo-statement that returns \(n+1\) - element
tuple, where \(n\) was a number of its parameters and tries to scanf these
from the next stdin line. Whole line is fetched, so each scan must expect
a separate, one newline. Also only builtin types are expected. The first
element of the tuple tells the user how many elements were scanned
properly, 0 means none. The rest of the unscanned args have their default
values (since null is not supported). The function does not distinguish
from IO error and parasing error and will return 0 as first argument on
any IO error.
\item \texttt{assert} - obvious. Used mostly in testing.
\end{itemize}

\section*{Disclaimer:}
\label{sec:org8e98d99}
Most of the ideas here (especially the '!' operator, but also the basics for
the assigment syntax) were invented (or at least gathered up and presented) by
Jonathan Blow in his talk 'Ideas for a new programming language for
games'. When he described something similar (syntax is slightly different that
what I've came up with): \url{https://www.youtube.com/watch?v=TH9VCN6UkyQ}.

\clearpage

\section*{Cennik:}
\label{sec:orgc47b05b}
\begin{minted}{cpp}
  Na 15 punktów
X 01 (trzy typy)
X 02 (literały, arytmetyka, porównania)
X 03 (zmienne, przypisanie)
X 04 (print)
X 05 (while, if)
X 06 (funkcje lub procedury, rekurencja)
X 07 (przez zmienną / przez wartość / in/out) [przez wartość]
X 08 (zmienne read-only i pętla for)
  Na 20 punktów
X 09 (przesłanianie i statyczne wiązanie)
X 10 (obsługa błędów wykonania)
X 11 (funkcje zwracające wartość)
  Na 30 punktów
X 12 (4) (statyczne typowanie)
X 13 (2) (funkcje zagnieżdżone ze statycznym wiązaniem)
X 14 (1) (rekordy/tablice/listy) [rekordy]
X 15 (2) (krotki z przypisaniem)
X 16 (1) (break, continue)
  17 (4) (funkcje wyższego rzędu, anonimowe, domknięcia)
  18 (3) (generatory)

X 99     ('new' syntax)
X 99     (iife)
X 99     ('bind' operator)

Razem: 30
\end{minted}
\end{document}

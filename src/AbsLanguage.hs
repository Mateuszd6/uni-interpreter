

module AbsLanguage where

-- Haskell module generated by the BNF converter




newtype Ident = Ident String deriving (Eq, Ord, Show, Read)
data Program a = Prog a [Stmt a]
  deriving (Eq, Ord, Show, Read)

instance Functor Program where
    fmap f x = case x of
        Prog a stmts -> Prog (f a) (map (fmap f) stmts)
data LValue a = LValueVar a Ident | LValueMemb a (LValue a) Ident
  deriving (Eq, Ord, Show, Read)

instance Functor LValue where
    fmap f x = case x of
        LValueVar a ident -> LValueVar (f a) ident
        LValueMemb a lvalue ident -> LValueMemb (f a) (fmap f lvalue) ident
data Expr a
    = ELor a (Expr a) (Expr a)
    | ELand a (Expr a) (Expr a)
    | EXor a (Expr a) (Expr a)
    | EEq a (Expr a) (Expr a)
    | ENeq a (Expr a) (Expr a)
    | EGeq a (Expr a) (Expr a)
    | ELeq a (Expr a) (Expr a)
    | EGt a (Expr a) (Expr a)
    | ELt a (Expr a) (Expr a)
    | EPlus a (Expr a) (Expr a)
    | EMinus a (Expr a) (Expr a)
    | ECat a (Expr a) (Expr a)
    | ETimes a (Expr a) (Expr a)
    | EDiv a (Expr a) (Expr a)
    | EMod a (Expr a) (Expr a)
    | EPow a (Expr a) (Expr a)
    | EFnCall a Ident (InvokeExprList a)
    | EScan a [Type a]
    | EIife a (FunDecl a) (InvokeExprList a)
    | ELValue a (LValue a)
    | ENew a Ident [NewFieldAsgn a]
    | EString a String
    | EInt a Integer
    | EBool a (Boolean a)
  deriving (Eq, Ord, Show, Read)

instance Functor Expr where
    fmap f x = case x of
        ELor a expr1 expr2 -> ELor (f a) (fmap f expr1) (fmap f expr2)
        ELand a expr1 expr2 -> ELand (f a) (fmap f expr1) (fmap f expr2)
        EXor a expr1 expr2 -> EXor (f a) (fmap f expr1) (fmap f expr2)
        EEq a expr1 expr2 -> EEq (f a) (fmap f expr1) (fmap f expr2)
        ENeq a expr1 expr2 -> ENeq (f a) (fmap f expr1) (fmap f expr2)
        EGeq a expr1 expr2 -> EGeq (f a) (fmap f expr1) (fmap f expr2)
        ELeq a expr1 expr2 -> ELeq (f a) (fmap f expr1) (fmap f expr2)
        EGt a expr1 expr2 -> EGt (f a) (fmap f expr1) (fmap f expr2)
        ELt a expr1 expr2 -> ELt (f a) (fmap f expr1) (fmap f expr2)
        EPlus a expr1 expr2 -> EPlus (f a) (fmap f expr1) (fmap f expr2)
        EMinus a expr1 expr2 -> EMinus (f a) (fmap f expr1) (fmap f expr2)
        ECat a expr1 expr2 -> ECat (f a) (fmap f expr1) (fmap f expr2)
        ETimes a expr1 expr2 -> ETimes (f a) (fmap f expr1) (fmap f expr2)
        EDiv a expr1 expr2 -> EDiv (f a) (fmap f expr1) (fmap f expr2)
        EMod a expr1 expr2 -> EMod (f a) (fmap f expr1) (fmap f expr2)
        EPow a expr1 expr2 -> EPow (f a) (fmap f expr1) (fmap f expr2)
        EFnCall a ident invokeexprlist -> EFnCall (f a) ident (fmap f invokeexprlist)
        EScan a types -> EScan (f a) (map (fmap f) types)
        EIife a fundecl invokeexprlist -> EIife (f a) (fmap f fundecl) (fmap f invokeexprlist)
        ELValue a lvalue -> ELValue (f a) (fmap f lvalue)
        ENew a ident newfieldasgns -> ENew (f a) ident (map (fmap f) newfieldasgns)
        EString a string -> EString (f a) string
        EInt a integer -> EInt (f a) integer
        EBool a boolean -> EBool (f a) (fmap f boolean)
data NewFieldAsgn a = NFADefault a Ident (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor NewFieldAsgn where
    fmap f x = case x of
        NFADefault a ident expr -> NFADefault (f a) ident (fmap f expr)
data ExprOrTuple a = EOTRegular a (Expr a) | EOTTuple a [Expr a]
  deriving (Eq, Ord, Show, Read)

instance Functor ExprOrTuple where
    fmap f x = case x of
        EOTRegular a expr -> EOTRegular (f a) (fmap f expr)
        EOTTuple a exprs -> EOTTuple (f a) (map (fmap f) exprs)
data Stmt a
    = SIf a (Expr a) (Stmt a)
    | SIfElse a (Expr a) (Stmt a) (Stmt a)
    | SFor a Ident (Expr a) (Expr a) (Stmt a)
    | SWhile a (Expr a) (Stmt a)
    | SExpr a (Expr a)
    | SVDecl a (VarDecl a)
    | SFDecl a Ident (FunDecl a)
    | SSDecl a Ident (StrcDecl a)
    | STDecl a (TupleTarget a) (ExprOrTuple a)
    | SAssign a (LValue a) (Expr a)
    | STAssign a (TupleTarget a) (ExprOrTuple a)
    | SIgnore a (ExprOrTuple a)
    | SReturn a (ReturnExpr a)
    | SBreak a
    | SCont a
    | SAssert a (Expr a)
    | SPrint a [Expr a]
    | SBlock a (Bind a) [Stmt a]
  deriving (Eq, Ord, Show, Read)

instance Functor Stmt where
    fmap f x = case x of
        SIf a expr stmt -> SIf (f a) (fmap f expr) (fmap f stmt)
        SIfElse a expr stmt1 stmt2 -> SIfElse (f a) (fmap f expr) (fmap f stmt1) (fmap f stmt2)
        SFor a ident expr1 expr2 stmt -> SFor (f a) ident (fmap f expr1) (fmap f expr2) (fmap f stmt)
        SWhile a expr stmt -> SWhile (f a) (fmap f expr) (fmap f stmt)
        SExpr a expr -> SExpr (f a) (fmap f expr)
        SVDecl a vardecl -> SVDecl (f a) (fmap f vardecl)
        SFDecl a ident fundecl -> SFDecl (f a) ident (fmap f fundecl)
        SSDecl a ident strcdecl -> SSDecl (f a) ident (fmap f strcdecl)
        STDecl a tupletarget exprortuple -> STDecl (f a) (fmap f tupletarget) (fmap f exprortuple)
        SAssign a lvalue expr -> SAssign (f a) (fmap f lvalue) (fmap f expr)
        STAssign a tupletarget exprortuple -> STAssign (f a) (fmap f tupletarget) (fmap f exprortuple)
        SIgnore a exprortuple -> SIgnore (f a) (fmap f exprortuple)
        SReturn a returnexpr -> SReturn (f a) (fmap f returnexpr)
        SBreak a -> SBreak (f a)
        SCont a -> SCont (f a)
        SAssert a expr -> SAssert (f a) (fmap f expr)
        SPrint a exprs -> SPrint (f a) (map (fmap f) exprs)
        SBlock a bind stmts -> SBlock (f a) (fmap f bind) (map (fmap f) stmts)
data TupleTarget a = TTar a [IdentOrIgnr a]
  deriving (Eq, Ord, Show, Read)

instance Functor TupleTarget where
    fmap f x = case x of
        TTar a identorignrs -> TTar (f a) (map (fmap f) identorignrs)
data IdentOrIgnr a = IOIIdent a Ident | IOIIgnore a
  deriving (Eq, Ord, Show, Read)

instance Functor IdentOrIgnr where
    fmap f x = case x of
        IOIIdent a ident -> IOIIdent (f a) ident
        IOIIgnore a -> IOIIgnore (f a)
data VarDecl a
    = DVDecl a Ident (VarSpec a) (Type a)
    | DVDeclAsgn a Ident (VarSpec a) (Type a) (Expr a)
    | DVDeclDeduce a Ident (VarSpec a) (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor VarDecl where
    fmap f x = case x of
        DVDecl a ident varspec type_ -> DVDecl (f a) ident (fmap f varspec) (fmap f type_)
        DVDeclAsgn a ident varspec type_ expr -> DVDeclAsgn (f a) ident (fmap f varspec) (fmap f type_) (fmap f expr)
        DVDeclDeduce a ident varspec expr -> DVDeclDeduce (f a) ident (fmap f varspec) (fmap f expr)
data VarSpec a = VSReadOnly a | VSNone a
  deriving (Eq, Ord, Show, Read)

instance Functor VarSpec where
    fmap f x = case x of
        VSReadOnly a -> VSReadOnly (f a)
        VSNone a -> VSNone (f a)
data StrcDecl a = SDDefault a (StrcMembers a)
  deriving (Eq, Ord, Show, Read)

instance Functor StrcDecl where
    fmap f x = case x of
        SDDefault a strcmembers -> SDDefault (f a) (fmap f strcmembers)
data StrcMembers a = SMDefault a [DeclStrcMember a] | SMEmpty a
  deriving (Eq, Ord, Show, Read)

instance Functor StrcMembers where
    fmap f x = case x of
        SMDefault a declstrcmembers -> SMDefault (f a) (map (fmap f) declstrcmembers)
        SMEmpty a -> SMEmpty (f a)
data DeclStrcMember a = DStrMem a Ident (Type a)
  deriving (Eq, Ord, Show, Read)

instance Functor DeclStrcMember where
    fmap f x = case x of
        DStrMem a ident type_ -> DStrMem (f a) ident (fmap f type_)
data FunDecl a
    = FDDefault a (FunParams a) (Bind a) (FuncRetT a) [Stmt a]
  deriving (Eq, Ord, Show, Read)

instance Functor FunDecl where
    fmap f x = case x of
        FDDefault a funparams bind funcrett stmts -> FDDefault (f a) (fmap f funparams) (fmap f bind) (fmap f funcrett) (map (fmap f) stmts)
data Bind a
    = BdDefault a [Ident] | BdPure a | BdPureAlt a | BdNone a
  deriving (Eq, Ord, Show, Read)

instance Functor Bind where
    fmap f x = case x of
        BdDefault a idents -> BdDefault (f a) idents
        BdPure a -> BdPure (f a)
        BdPureAlt a -> BdPureAlt (f a)
        BdNone a -> BdNone (f a)
data InvokeExprList a = IELDefault a [Expr a] | IELEmpty a
  deriving (Eq, Ord, Show, Read)

instance Functor InvokeExprList where
    fmap f x = case x of
        IELDefault a exprs -> IELDefault (f a) (map (fmap f) exprs)
        IELEmpty a -> IELEmpty (f a)
data DeclFunParam a = DDeclBasic a Ident (VarSpec a) (Type a)
  deriving (Eq, Ord, Show, Read)

instance Functor DeclFunParam where
    fmap f x = case x of
        DDeclBasic a ident varspec type_ -> DDeclBasic (f a) ident (fmap f varspec) (fmap f type_)
data ReturnExpr a = RExNone a | RExRegular a (ExprOrTuple a)
  deriving (Eq, Ord, Show, Read)

instance Functor ReturnExpr where
    fmap f x = case x of
        RExNone a -> RExNone (f a)
        RExRegular a exprortuple -> RExRegular (f a) (fmap f exprortuple)
data FunParams a = FPList a [DeclFunParam a] | FPEmpty a
  deriving (Eq, Ord, Show, Read)

instance Functor FunParams where
    fmap f x = case x of
        FPList a declfunparams -> FPList (f a) (map (fmap f) declfunparams)
        FPEmpty a -> FPEmpty (f a)
data FuncRetT a
    = FRTSingle a (Type a) | FRTTuple a [Type a] | FRTEmpty a
  deriving (Eq, Ord, Show, Read)

instance Functor FuncRetT where
    fmap f x = case x of
        FRTSingle a type_ -> FRTSingle (f a) (fmap f type_)
        FRTTuple a types -> FRTTuple (f a) (map (fmap f) types)
        FRTEmpty a -> FRTEmpty (f a)
data Type a = TInt a | TBool a | TString a | TUser a Ident
  deriving (Eq, Ord, Show, Read)

instance Functor Type where
    fmap f x = case x of
        TInt a -> TInt (f a)
        TBool a -> TBool (f a)
        TString a -> TString (f a)
        TUser a ident -> TUser (f a) ident
data Boolean a = BTrue a | BFalse a
  deriving (Eq, Ord, Show, Read)

instance Functor Boolean where
    fmap f x = case x of
        BTrue a -> BTrue (f a)
        BFalse a -> BFalse (f a)

-- TODO: Investigate
[].       [Stm]    ::= ; -- TODO: move this to statemetns, place more logically.
(:).      [Stm]    ::= Stm [Stm] ;

EPlus.   Exp   ::= Exp  "+" Exp2 ;
EMinus.  Exp   ::= Exp  "-" Exp2 ;

ETimes.  Exp2  ::= Exp2 "*" Exp3 ;
EDiv.    Exp2  ::= Exp2 "/" Exp3 ;

EPow.    Exp3  ::= Exp3 "^" Exp4 ;

EEq.     Exp4  ::= Exp4 "==" Exp5 ;
ENeq.    Exp4  ::= Exp4 "!=" Exp5 ;
EGeq.    Exp4  ::= Exp4 ">=" Exp5 ;
ELeq.    Exp4  ::= Exp4 "<=" Exp5 ;
EGt.     Exp4  ::= Exp4 ">"  Exp5 ;
ELt.     Exp4  ::= Exp4 "<"  Exp5 ;

ELor.    Exp5  ::= Exp5 "||" Exp6 ;
ELand.   Exp5  ::= Exp5 "&&" Exp6 ;
EXor.    Exp5  ::= Exp5 "^^" Exp6 ;

EFnCall. Exp6  ::= Ident InvokeExprList ;

-- 'Lambda' funciton. Sicne we don't have a higher order funcs, all we can do
-- with it, is to immidietly invoke it (IIFE).
EIife.   Exp6  ::= FunDecl InvokeExprList ;

ETuple.  Exp7  ::= "[" [Exp] "]" ;

EVar.    Exp8  ::= Ident ;
EString. Exp8  ::= String ;
EInt.    Exp8  ::= Integer ;
EBool.   Exp8  ::= Boolean ;

-- NOTE: Equivalent to: (TODO: Shorten when sure)
-- _.       Exp   ::= Exp1 ;
-- _.       Exp1  ::= Exp2 ;
-- _.       Exp2  ::= Exp3 ;
-- _.       Exp3  ::= Exp4 ;
-- _.       Exp4  ::= Exp5 ;
-- _.       Exp5  ::= Exp6 ;
-- _.       Exp6  ::= Exp7 ;
-- _.       Exp7  ::= Exp8 ;
-- _.       Exp8  ::= "(" Exp ")" ;
coercions Exp 8 ;

-- Split into Stm1 and Stm to avoid confilits around if - else, which happen
-- becase we are not using endif or anything like this.
-- TODO: We cannot do for () if () {}
SIf.     Stm  ::= IfStm ElseStm ; -- ElseStm can be empty to allow single if.
SExp.    Stm1 ::= Exp ";" ;
SDecl.   Stm1 ::= Decl ";" ;
SFDecl.  Stm1 ::= Ident "::" FunDecl ; -- Local function declaration
SSDecl.  Stm1 ::= Ident "::" "struct" "{" [DeclSuperBasic] "}" ;
SAssign. Stm1 ::= AssignVar "=" Exp ";";
SReturn. Stm1 ::= "return" Exp ";" ; -- TODO: Return in void functions won't work?
SForInt. Stm1 ::= "for" "(" Ident ":" Exp ".." Exp ")" Stm1 ;
SWhile.  Stm1 ::= "while" "(" Exp ")" Stm1 ;
SBlock.  Stm1 ::= FunBind "{" [Stm] "}" ;
_.       Stm  ::= Stm1 ;

-- TODO: Split fun definition with declaration, for clarity
FDDefault.  FunDecl ::= DeclList "->" FuncRetV FunBind "{" [Stm] "}" ;
FDBindEmpty.FunBind ::= ;
FDBindSpec. FunBind ::= "bind" NameList ; -- bind () is same as not specifying bind at all

DDeclUninit.   Decl ::= AssignVar ":" Type ; -- Declare do not assign value.
DDeclAssign.   Decl ::= AssignVar ":" Type "=" Exp ; -- Decalre + assign, type is explicit.
DDeclDeduce.   Decl ::= AssignVar ":" "=" Exp ; -- Decalre + assign, type is deduced.

-- TODO: 'tuple' here is necesarry to avoid ugly conflicts?
AVSingle. AssignVar ::= Ident ;
AVTuple.  AssignVar ::= "tuple" "[" [AssignVar] "]" ;

AVSBSingle. DeclSuperBasic ::= Ident ":" Type ; -- TODO: This does not stay!

IIf.        IfStm   ::= "if" "(" Exp ")" Stm1 ;
IElse.      ElseStm ::= "else" Stm ;
IElseEmpty. ElseStm ::= ;

-- Passing bing() to function is allowed, it basically means that the function
-- is pure.
INameListDefault. NameList ::= "(" [Ident] ")" ;
INameListEmpty.   NameList ::= "(" ")" ;

IELDefault. InvokeExprList ::= "(" [Exp] ")" ;
IELEmpty.   InvokeExprList ::= "(" ")" ;

DDeclBasic. DeclBasic      ::= AssignVar ":" Type; -- TODO: Can this go?
DLDefault.  DeclList       ::= "(" [DeclBasic] ")" ;
DLEmpty.    DeclList       ::= "(" ")" ;

-- Function return type, user is allowed to skip it, if func does not return
-- anything ('void' return type).
FRDefault.  FuncRetV ::= Type ;
FREmpty.    FuncRetV ::= ;

-- Type name: either built-in or user-defined struct.
TInt.     Type    ::= "int" ;
TBool.    Type    ::= "bool" ;
TString.  Type    ::= "string" ;
TTuple.   Type    ::= "[" [Type] "]" ;
TUserDef. Type    ::= Ident ;

BTrue.   Boolean  ::= "true" ;
BFalse.  Boolean  ::= "false" ;

(:[]).   [DeclBasic] ::= DeclBasic ;
(:).     [DeclBasic] ::= DeclBasic "," [DeclBasic] ;

(:[]).   [Exp] ::= Exp ;
(:).     [Exp] ::= Exp "," [Exp] ;

(:[]).   [Ident] ::= Ident ;
(:).     [Ident] ::= Ident "," [Ident] ;

(:[]).   [DeclSuperBasic] ::= DeclSuperBasic ";" ;
(:).     [DeclSuperBasic] ::= DeclSuperBasic ";" [DeclSuperBasic] ;

(:[]).   [AssignVar] ::= AssignVar ;
(:).     [AssignVar] ::= AssignVar "," [AssignVar] ;

(:[]).   [Type] ::= Type ;
(:).     [Type] ::= Type "," [Type] ;

comment "//" ; -- Regular C style comments both block and single-line.
comment "/*" "*/" ; -- Block comments can't be nested (like in C).
comment "#" ; -- To allow scripting

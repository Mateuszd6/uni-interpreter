// Tests and comments (this file should be parsed with no issues):

// The 'program' in a sequence of statements written from the top to the bottom.
// Instructions are executed one-after-another.  Functions and variables
// declared without parent scope are considered global.  User can never redefine
// a global variable / function. This results in runtime (of course)
// error. Locally defined symbols are visible in their scope (like in C). User
// can't redefine symbol in the same scope. For example the following:

// '{ foo : int = 0; foo : int = 0; }' would parse but fails at runtime. Same
// rules apply to functions and structs.

// Declarations:

// Define variable.
// (type is either string / int / bool or user-defined struct (see: structs)):
variable_name : variable_type ;
foo : int ;

// Declare and assign value.
foo : int = 4;

// Declare, assign but deduce the type.
foo := 4;

// The idea is that user can 'skip' the part of declaration he does not want,
// like skip the type if type can be deduced (deducing type works, because the
// language is statically typed). Also the difference between declaration and
// simple assigment is the ':' which appears in every type of declaration.
// Asignments however:
foo = 4;
// ... does not have this token and are simple C-like assignments.

// Expressions are basic arithmetic and logic expressions taken straight from C,
// operator @ for string concatenation and IIFE invokation (in grammar called
// EIife, described later here in the 'functions' part).

// Struct definitions. Very similar to C, just with slightly different syntax.
foo :: struct
{
}

bar :: struct
{
    x : int;
}

baz :: struct
{
    x : int;
    y : int;
}

v3 :: struct
{
    x : int;
    y : int;
    z : int;
}

quater :: struct
{
    e : v3;
    w : int;
}

example_vector : v3;
example_quaterion : quater;
x_copy = example_vector.x; // Getting struct members like in C.
x_copy_q = example_quaterion.e.x; // dots can follow one another.
// nope := example_vector.(e.x); // stuff like this won't parse of course.

// Of course in the above examples, the variables would be uninitialized, which
// causes a runtime error.

// Structs can be defined for the scope:
{
    foobar :: struct
    {
        zzz : string;
    }

    m : foobar;
    m.zzz = "mateusz";
}

// Most important feature of the language is a '!' (bind) operator. This was
// design to make code refactoring easier by specifying which variables can be
// accessed in the block / lambda / function. There is a little difference
// between these anyway.

// Super boring example, regular named (global) function.
exmaple1 :: (x : int, y : int) -> int
{
    return y * x;
}

// Return type can be ommited, if function does not return.
out : int = 0;
exmaple2 :: (x : int, y : int)
{
    out = y * x;
}

// Function that binds a variable - only foo (and of course function params) are
// visible inside the function body. Everything should be an interpreter error.
foo : int = 12;
exmaple3 :: (x : int, y: int) !(foo) -> int
{
    return foo + y * x;
}

// This function is pure. It is not the same as skipping '!' - single '!' means
// fucntion can refer to _non_ variables (aka. is pure), skipping '!' allows it
// to refer to all variables (like in C).
foo : int = 12;
exmaple4 :: (x : int, y: int)! -> int
{
    // foo can't be accessed here, the function is pure.
    return y * x;
}

// This function is not pure, and can reference every variable in its scope. It
// means global variables + local scope variables, if function is defined in the
// local scope.
foo : int = 12;
exmaple5 :: (x : int, y: int) -> int
{
    return foo + y * x;
}

// Nested functions.
exmaple6 :: (x : int, y: int)! -> int
{
    square :: (x : int)! -> int
    {
        return x * x;
    }

    return square(x) + square(y);
}

// Lambda expressions. Since we don't have a higher order funcs (no passing, no
// returning function), all we can do with it, is to immidietly invoke it (IIFE)
// This is usefull when we have block that caluclates something and we want to
// keep it as pure as possible.
iife_example1 :: (x : int, y : int)!
{
    out : int = 0;

    {
        x = x + 6;
        y = y - x;
        x = x * y;
        y = x - 5;
        out = x + y;
    }
}

// We could make it a little more safe and refactoring friendly by binding x and
// y and out in the block, so that we can't refer to anything else.
foo : int = 42;
iife_example2 :: (x : int, y : int)!
{
    out : int = 0;
    !(x, y, out)
    {
        x = x + 6;
        y = y - x;
        x = x * y;
        y = x - 5;
        out = x + y;
    }
}

// We have to declare out and then change if, which is ugly and bugprone, thats
// where IIFE comes to help us.
iife_example3 :: (x : int, y : int)!
{
    // We can define out and assgin it at the same time. Assing 'out' to
    // Immidietly Called Function Expression which can refer only to x and y
    // and computes something from them as purely as it is possible.
    out : int = () !(x, y) -> int {
        x = x + 6;
        y = y - x;
        x = x * y;
        y = x - 5;
        return x + y;
    }();

    // Alternatively, we could do:
    out : int = (x_ : int, y_ : int)! -> int {
        x_ = x_ + 6;
        y_ = y_ - x_;
        x_ = x_ * y_;
        y_ = x_ - 5;
        return x_ + y_;
    }();
    // ... which achieves the same, but is less ugly.
}

// The whole idea about it is that is is very easy to extract code from block
// into 'binded' block or iife, into local function, into global function, which
// all have a very similar syntax (lambda, aka. 'unnamed_function' definition
// sytnax is the same as 'named function', but without the name). Which is not
// what most languages offer (like in C++, lambdas have everything differently
// than regular functions).

// The interpreter provides following 'standard library' functions:
// * :: read_int ()! -> [bool, int]      : Read an integer from stdin.
// * :: read_string ()! -> [bool, int]   : Read a string from stdin.
// * :: write_int ()! -> [bool]          : Write an int to stdout.
// * :: write_string ()! -> [bool]       : Write a string to stdout.
// * :: die (string)!                    : Kill program execution (with message).
//
// IO functions return a boolean telling if the operation succeeded or not.

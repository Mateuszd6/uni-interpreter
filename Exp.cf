-- TODO: This is smarter way to write empty?
-- [].       [Stm]    ::= ; -- TODO: move this to statemetns, place more logically.
-- (:).      [Stm]    ::= Stm [Stm] ;

-- TODO: Investigate entry point.
entrypoints Program ;
Prog.   Program ::= [Stm] ;

-- This makes parsing much easier and enforces that ugly things like (1 + 2).foo
-- won't parse. Iur language is simple enought that it makes sense; no lists,
-- records just strings so the only thing we would like to have on the LHS when
-- e.g. assigning, is either an existing variable name, or its member.
LValueVar.  LValue ::= Ident ;
LValueMemb. LValue ::= LValue "." Ident ;

-- TODO: Make tuple decl and tie in statements, no expr.
EPlus.   Exp   ::= Exp "+" Exp2 ;
EMinus.  Exp   ::= Exp "-" Exp2 ;

ETimes.  Exp2  ::= Exp2 "*" Exp3 ;
EDiv.    Exp2  ::= Exp2 "/" Exp3 ;

EPow.    Exp3  ::= Exp3 "^" Exp4 ;

EEq.     Exp4  ::= Exp4 "==" Exp5 ;
ENeq.    Exp4  ::= Exp4 "!=" Exp5 ;
EGeq.    Exp4  ::= Exp4 ">=" Exp5 ;
ELeq.    Exp4  ::= Exp4 "<=" Exp5 ;
EGt.     Exp4  ::= Exp4 ">"  Exp5 ;
ELt.     Exp4  ::= Exp4 "<"  Exp5 ;

ELor.    Exp5  ::= Exp5 "||" Exp6 ;
ELand.   Exp5  ::= Exp5 "&&" Exp6 ;
EXor.    Exp5  ::= Exp5 "^^" Exp6 ;

EFnCall. Exp6  ::= Ident InvokeExprList ;

-- 'Lambda' funciton. TODO: READ MODE.
EIife.   Exp6  ::= FunDecl InvokeExprList ;

ELValue. Exp7  ::= LValue ;

EString. Exp8  ::= String ;
EInt.    Exp8  ::= Integer ;
EBool.   Exp8  ::= Boolean ;

-- Nested tuples would parse, but language does not support them.
-- ETuple.  Exp9   ::= "[" [Ident] "]" ; -- TODO

-- TODO: Remove when sure:
-- NOTE: Equivalent to:
-- _.       Exp   ::= Exp1 ;
-- (...)
-- _.       Exp8  ::= "(" Exp ")" ;
coercions Exp 8 ;

-- Split into Stm1 and Stm to avoid confilits around if - else, which happen
-- becase we are not using endif or anything like this.
-- TODO: We cannot do for () if () {}
SIf.     Stm  ::= IfStm ElseStm ; -- ElseStm can be empty to allow single if.
SExp.    Stm1 ::= Exp ";" ;
SDecl.   Stm1 ::= Decl ";" ;
SFDecl.  Stm1 ::= Ident "::" FunDecl ;
SSDecl.  Stm1 ::= Ident "::" StructDecl ;
SAssign. Stm1 ::= LValue "=" Exp ";" ; -- TODO: Could be 'Ident "=" Exp', but member access: 'foo.bar = "xyz"';
STAssign.Stm1 ::= TupleAssign TupleExp ";" ; -- TODO: This is acutally TupleAssignOrDeclare
SReturn. Stm1 ::= "return" ReturnExp ";" ; -- TODO: Return in void functions won't work?
SForInt. Stm1 ::= "for" "(" Ident ":" Exp ".." Exp ")" Stm1 ; -- This declares new variable.
SWhile.  Stm1 ::= "while" "(" Exp ")" Stm1 ;
SBlock.  Stm1 ::= FunBind "{" [Stm] "}" ;
_.       Stm  ::= Stm1 ;

(:[]).   [Stm] ::= Stm ;
(:).     [Stm] ::= Stm [Stm] ;

-- Tuple is not a stand-alone expression to avoid conflicts and issues
-- with nesting tuples. Languege supports neither by design. Stuff
-- like '[1];' '[1 + 2];' '[a, b];' does not parse. They only thing we
-- can do with tuple is to assign it, or return it. -- TODO: Docs.
TExDefault. TupleExp ::= "[" [Exp] "]";

RExRegular. ReturnExp ::= Exp ;
RExTuple.   ReturnExp ::= TupleExp ;

-- TODO: Split fun definition with declaration, for clarity
FDDefault. FunDecl ::= FunParams FunBind FuncRetT "{" [Stm] "}" ;
SDDefault. StructDecl ::= "struct" "{" StructMembers "}" ;

SMDefault. StructMembers ::= [DeclSuperBasic] ;
SMEmpty.   StructMembers ::= ; -- To allow empty structs.

FDBindDefault.FunBind ::= "!" "(" [Ident] ")";
FDBindPure.   FunBind ::= "!" "(" ")" ; -- bind () is same as not specifying bind at all
FDBindPure2.  FunBind ::= "!" ; -- user is allowed to skip paren here
FDBindNone.   FunBind ::= ; -- No bind means the function can refer to any variable from outside scope.

DDeclUninit.   Decl ::= Ident ":" Type ; -- Declare do not assign value.
DDeclAssign.   Decl ::= Ident ":" Type "=" Exp ; -- Decalre + assign, type is explicit.
DDeclDeduce.   Decl ::= Ident ":" "=" Exp ; -- Decalre + assign, type is deduced.

TADeclare.     TupleAssign ::= "[" [Ident] "]" ":" "=" ; -- declare new variables
TATie.         TupleAssign ::= "[" [Ident] "]" "=" ; -- assign values of existing variables (like c++'s std::tie)

AVSBSingle. DeclSuperBasic ::= Ident ":" Type ; -- TODO: This does not stay!

IIf.        IfStm   ::= "if" "(" Exp ")" Stm1 ;
IElse.      ElseStm ::= "else" Stm ;
IElseEmpty. ElseStm ::= ;

IELDefault. InvokeExprList ::= "(" [Exp] ")" ;
IELEmpty.   InvokeExprList ::= "(" ")" ;

DDeclBasic. DeclBasic   ::= Ident ":" Type ;
(:[]).      [DeclBasic] ::= DeclBasic ;
(:).        [DeclBasic] ::= DeclBasic "," [DeclBasic] ;

FPDefault.  FunParams   ::= "(" [DeclBasic] ")" ;
FPEmpty.    FunParams   ::= "(" ")" ;

-- Function return type, user is allowed to skip it, if func does not return
-- anything ('void' return type).
-- TODO: Rename to FuncRetType?
FRTDefault.  FuncRetT ::= "->" Type ;
FRTTuple.    FuncRetT ::= "->" "[" [Type] "]" ; -- Tuple (No nesting tuples).
FRTEmpty.    FuncRetT ::= ; -- User is allowed to skip -> when no return type.

-- Type name: either built-in or user-defined struct.
TInt.     Type    ::= "int" ;
TBool.    Type    ::= "bool" ;
TString.  Type    ::= "string" ;
TUserDef. Type    ::= Ident ;

BTrue.   Boolean  ::= "true" ;
BFalse.  Boolean  ::= "false" ;

(:[]).   [Exp] ::= Exp ;
(:).     [Exp] ::= Exp "," [Exp] ;

(:[]).   [Ident] ::= Ident ;
(:).     [Ident] ::= Ident "," [Ident] ;

(:[]).   [DeclSuperBasic] ::= DeclSuperBasic ";" ;
(:).     [DeclSuperBasic] ::= DeclSuperBasic ";" [DeclSuperBasic] ;

(:[]).   [Type] ::= Type ;
(:).     [Type] ::= Type "," [Type] ;

comment "//" ; -- Regular C style comments both block and single-line.
comment "/*" "*/" ; -- Block comments can't be nested (like in C).
comment "#" ; -- To allow scripting

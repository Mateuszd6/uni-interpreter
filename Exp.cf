-- TODO: This is smarter way to write empty?
-- [].       [Stm]    ::= ; -- TODO: move this to statemetns, place more logically.
-- (:).      [Stm]    ::= Stm [Stm] ;

entrypoints Program ;
Prog.   Program ::= [Stm] ;

-- This makes parsing much easier and enforces that ugly things like (1 + 2).foo
-- won't parse. Iur language is simple enought that it makes sense; no lists,
-- records just strings so the only thing we would like to have on the LHS when
-- e.g. assigning, is either an existing variable name, or its member.
LValueVar.  LValue ::= Ident ;
LValueMemb. LValue ::= LValue "." Ident ;

-- TODO: Make tuple decl and tie in statements, no expr.
EPlus.   Exp   ::= Exp "+" Exp2 ;
EMinus.  Exp   ::= Exp "-" Exp2 ;

ETimes.  Exp2  ::= Exp2 "*" Exp3 ;
EDiv.    Exp2  ::= Exp2 "/" Exp3 ;

EPow.    Exp3  ::= Exp3 "^" Exp4 ;

EEq.     Exp4  ::= Exp4 "==" Exp5 ;
ENeq.    Exp4  ::= Exp4 "!=" Exp5 ;
EGeq.    Exp4  ::= Exp4 ">=" Exp5 ;
ELeq.    Exp4  ::= Exp4 "<=" Exp5 ;
EGt.     Exp4  ::= Exp4 ">"  Exp5 ;
ELt.     Exp4  ::= Exp4 "<"  Exp5 ;

ELor.    Exp5  ::= Exp5 "||" Exp6 ;
ELand.   Exp5  ::= Exp5 "&&" Exp6 ;
EXor.    Exp5  ::= Exp5 "^^" Exp6 ;

EFnCall. Exp6  ::= Ident InvokeExprList ;
EIife.   Exp6  ::= FunDecl InvokeExprList ; -- IIFE (more in docs).

ELValue. Exp7  ::= LValue ;

EString. Exp8  ::= String ;
EInt.    Exp8  ::= Integer ;
EBool.   Exp8  ::= Boolean ;

-- Equivalent to: _. Exp ::= Exp1 ; (...) _. Exp8 ::= "(" Exp ")" ;
coercions Exp 8 ;

(:[]).   [Exp] ::= Exp ;
(:).     [Exp] ::= Exp "," [Exp] ;

-- Split into Stm1 and Stm to avoid confilits around if - else, which happen
-- becase we are not using endif or anything like this.
-- TODO: We cannot do for () if () {}
SIf.     Stm  ::= IfStm ElseStm ; -- ElseStm can be empty to allow single if.
SExp.    Stm1 ::= Exp ";" ;
SDecl.   Stm1 ::= Decl ";" ;
SFDecl.  Stm1 ::= Ident "::" FunDecl ;
SSDecl.  Stm1 ::= Ident "::" StructDecl ;
SAssign. Stm1 ::= LValue "=" Exp ";" ; -- TODO: Could be 'Ident "=" Exp', but member access: 'foo.bar = "xyz"';
STAssign.Stm1 ::= "[" [Ident] "]" "=" TupleExp ";" ; -- Tie existing variables.
STDecl.  Stm1 ::= "[" [Ident] "]" ":" "=" TupleExp ";" ; -- Declare new variables (types are always deduced).
SReturn. Stm1 ::= "return" ReturnExp ";" ; -- TODO: Return in void functions won't work?
SForInt. Stm1 ::= "for" "(" Ident ":" Exp ".." Exp ")" Stm1 ; -- This declares new variable.
SWhile.  Stm1 ::= "while" "(" Exp ")" Stm1 ;
SBlock.  Stm1 ::= FunBind "{" [Stm] "}" ;
_.       Stm  ::= Stm1 ;

(:[]).   [Stm] ::= Stm ;
(:).     [Stm] ::= Stm [Stm] ;

-- Tuple is not a stand-alone expression (more in docs).
-- Tuple is not a stand-alone expression to avoid conflicts and issues with
-- nesting tuples. Languege supports neither by design. Stuff like: '[1];'
-- '[1 + 2];' '[a, b];' does not parse. They only thing we can do with tuple is
-- to assign it, or return it. -- TODO: Docs.
TExDefault. TupleExp ::= "[" [Exp] "]";

RExRegular. ReturnExp ::= Exp ;
RExTuple.   ReturnExp ::= TupleExp ;

-- TODO: Split fun definition with declaration, for clarity
FDDefault. FunDecl ::= FunParams FunBind FuncRetT "{" [Stm] "}" ;
SDDefault. StructDecl ::= "struct" "{" StructMembers "}" ;

SMDefault. StructMembers ::= [DeclStructMember] ;
SMEmpty.   StructMembers ::= ; -- To allow empty structs.

FDBindDefault.FunBind ::= "!" "(" [Ident] ")";
FDBindPure.   FunBind ::= "!" "(" ")" ; -- bind () is same as not specifying bind at all
FDBindPure2.  FunBind ::= "!" ; -- user is allowed to skip paren here
FDBindNone.   FunBind ::= ; -- No bind means the function can refer to any variable from outside scope.

DDeclUninit.  Decl ::= Ident ":" Type ; -- Declare do not assign value.
DDeclAssign.  Decl ::= Ident ":" Type "=" Exp ; -- Decalre + assign, type is explicit.
DDeclDeduce.  Decl ::= Ident ":" "=" Exp ; -- Decalre + assign, type is deduced.

-- TODO: Tie could actually have LValues, not only idents like:
-- '[foo.x, foo.y] = funcitonThatReturnsAPair();' but I don't like the idea
-- fundamentally. Also it could generate some ugly conflicts.

IIf.        IfStm   ::= "if" "(" Exp ")" Stm1 ;
IElse.      ElseStm ::= "else" Stm ;
IElseEmpty. ElseStm ::= ;

IELDefault. InvokeExprList ::= "(" [Exp] ")" ;
IELEmpty.   InvokeExprList ::= "(" ")" ;

DDeclBasic. DeclBasic   ::= Ident ":" Type ;
(:[]).      [DeclBasic] ::= DeclBasic ;
(:).        [DeclBasic] ::= DeclBasic "," [DeclBasic] ;

FPDefault.  FunParams   ::= "(" [DeclBasic] ")" ;
FPEmpty.    FunParams   ::= "(" ")" ;

-- Function return type, user is allowed to skip it, if func does not return
-- anything ('void' return type).
-- TODO: Rename to FuncRetType?
FRTDefault.  FuncRetT ::= "->" Type ;
FRTTuple.    FuncRetT ::= "->" "[" [Type] "]" ; -- Tuple (No nesting tuples).
FRTEmpty.    FuncRetT ::= ; -- User is allowed to skip -> when no return type.

DStrMem. DeclStructMember   ::= DeclBasic ;
(:[]).   [DeclStructMember] ::= DeclStructMember ";" ;
(:).     [DeclStructMember] ::= DeclStructMember ";" [DeclStructMember] ;

TInt.     Type ::= "int" ;
TBool.    Type ::= "bool" ;
TString.  Type ::= "string" ;
TUserDef. Type ::= Ident ;

(:[]).   [Type]  ::= Type ;
(:).     [Type]  ::= Type "," [Type] ;

(:[]).   [Ident] ::= Ident ;
(:).     [Ident] ::= Ident "," [Ident] ;

BTrue.   Boolean ::= "true" ;
BFalse.  Boolean ::= "false" ;

comment "//" ; -- Regular C style comments both block and single-line.
comment "/*" "*/" ; -- Block comments can't be nested (like in C).
comment "#" ; -- To allow scripting

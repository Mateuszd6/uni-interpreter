module SkelLanguage where

-- Haskell module generated by the BNF converter

import AbsLanguage
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transIdent :: Ident -> Result
transIdent x = case x of
  Ident string -> failure x
transProgram :: Show a => Program a -> Result
transProgram x = case x of
  Prog _ stmts -> failure x
transLValue :: Show a => LValue a -> Result
transLValue x = case x of
  LValueVar _ ident -> failure x
  LValueMemb _ lvalue ident -> failure x
transExpr :: Show a => Expr a -> Result
transExpr x = case x of
  EPlus _ expr1 expr2 -> failure x
  EMinus _ expr1 expr2 -> failure x
  ECat _ expr1 expr2 -> failure x
  ETimes _ expr1 expr2 -> failure x
  EDiv _ expr1 expr2 -> failure x
  EPow _ expr1 expr2 -> failure x
  EEq _ expr1 expr2 -> failure x
  ENeq _ expr1 expr2 -> failure x
  EGeq _ expr1 expr2 -> failure x
  ELeq _ expr1 expr2 -> failure x
  EGt _ expr1 expr2 -> failure x
  ELt _ expr1 expr2 -> failure x
  ELor _ expr1 expr2 -> failure x
  ELand _ expr1 expr2 -> failure x
  EXor _ expr1 expr2 -> failure x
  EFnCall _ ident invokeexprlist -> failure x
  EIife _ fundecl invokeexprlist -> failure x
  ELValue _ lvalue -> failure x
  EString _ string -> failure x
  EInt _ integer -> failure x
  EBool _ boolean -> failure x
transExprOrTuple :: Show a => ExprOrTuple a -> Result
transExprOrTuple x = case x of
  EOTRegular _ expr -> failure x
  EOTTuple _ exprs -> failure x
transStmt :: Show a => Stmt a -> Result
transStmt x = case x of
  SIf _ expr stmt -> failure x
  SIfElse _ expr stmt1 stmt2 -> failure x
  SFor _ ident expr1 expr2 stmt -> failure x
  SWhile _ expr stmt -> failure x
  SExpr _ expr -> failure x
  SVDecl _ vardecl -> failure x
  SFDecl _ ident fundecl -> failure x
  SSDecl _ ident strcdecl -> failure x
  STDecl _ tupletarget exprortuple -> failure x
  SAssign _ lvalue expr -> failure x
  STAssign _ tupletarget exprortuple -> failure x
  SIgnore _ exprortuple -> failure x
  SReturn _ returnexpr -> failure x
  SBreak _ -> failure x
  SCont _ -> failure x
  SBlock _ bind stmts -> failure x
transTupleTarget :: Show a => TupleTarget a -> Result
transTupleTarget x = case x of
  TTar _ identorignrs -> failure x
transIdentOrIgnr :: Show a => IdentOrIgnr a -> Result
transIdentOrIgnr x = case x of
  IOIIdent _ ident -> failure x
  IOIIgnore _ -> failure x
transVarDecl :: Show a => VarDecl a -> Result
transVarDecl x = case x of
  DVDecl _ ident type_ -> failure x
  DVDeclAsgn _ ident type_ expr -> failure x
  DVDeclDeduce _ ident expr -> failure x
transStrcDecl :: Show a => StrcDecl a -> Result
transStrcDecl x = case x of
  SDDefault _ strcmembers -> failure x
transStrcMembers :: Show a => StrcMembers a -> Result
transStrcMembers x = case x of
  SMDefault _ declstrcmembers -> failure x
  SMEmpty _ -> failure x
transDeclStrcMember :: Show a => DeclStrcMember a -> Result
transDeclStrcMember x = case x of
  DStrMem _ ident type_ -> failure x
transFunDecl :: Show a => FunDecl a -> Result
transFunDecl x = case x of
  FDDefault _ funparams bind funcrett stmts -> failure x
transBind :: Show a => Bind a -> Result
transBind x = case x of
  BdDefault _ idents -> failure x
  BdPure _ -> failure x
  BdPureAlt _ -> failure x
  BdNone _ -> failure x
transInvokeExprList :: Show a => InvokeExprList a -> Result
transInvokeExprList x = case x of
  IELDefault _ exprs -> failure x
  IELEmpty _ -> failure x
transDeclFunParam :: Show a => DeclFunParam a -> Result
transDeclFunParam x = case x of
  DDeclBasic _ ident type_ -> failure x
transReturnExpr :: Show a => ReturnExpr a -> Result
transReturnExpr x = case x of
  RExNone _ -> failure x
  RExRegular _ exprortuple -> failure x
transFunParams :: Show a => FunParams a -> Result
transFunParams x = case x of
  FPList _ declfunparams -> failure x
  FPEmpty _ -> failure x
transFuncRetT :: Show a => FuncRetT a -> Result
transFuncRetT x = case x of
  FRTSingle _ type_ -> failure x
  FRTTuple _ types -> failure x
  FRTEmpty _ -> failure x
transType :: Show a => Type a -> Result
transType x = case x of
  TInt _ -> failure x
  TBool _ -> failure x
  TString _ -> failure x
  TUser _ ident -> failure x
transBoolean :: Show a => Boolean a -> Result
transBoolean x = case x of
  BTrue _ -> failure x
  BFalse _ -> failure x

